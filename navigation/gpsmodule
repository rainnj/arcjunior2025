import serial
import time
import csv
from datetime import datetime
from math import radians, cos, sin, asin, sqrt, atan2, degrees

# ==== SETTINGS ====
GPS_PORT = "COM12"  # Change to your port
GPS_BAUD = 9600
LOG_FILE = "gps_navigation_log.csv"
ARRIVAL_THRESHOLD_METERS = 5
NAVIGATION_UPDATE_RATE = 1  # seconds

# List of destination coordinates (latitude, longitude, name)
DESTINATIONS = [
    (52.475448, 13.457768, "one"),
]

# ======= SIMULATED COMPASS FUNCTIONS FOR WINDOWS =======
def init_compass():
    print("üß≠ (Simulated compass initialized - Windows mode)")

def read_compass_heading():
    return 90.0  # Always returns East (for simulation only)

# ======= UTILITIES =======
def haversine(lat1, lon1, lat2, lon2):
    R = 6371000
    dlat = radians(lat2 - lat1)
    dlon = radians(lon2 - lon1)
    a = sin(dlat/2)**2 + cos(radians(lat1)) * cos(radians(lat2)) * sin(dlon/2)**2
    c = 2 * asin(sqrt(a))
    return R * c

def parse_custom_line(line: str):
    try:
        if "Location:" in line and "Date:" in line:
            loc_part, date_part = line.split("  Date:")
            coords = loc_part.replace("Location:", "").strip().split(',')
            lat = float(coords[0])
            lon = float(coords[1])
            date_str = date_part.strip()
            return lat, lon, date_str
    except Exception as e:
        print(f"‚ùå Parse error: {e}")
    return None, None, None

def init_csv():
    with open(LOG_FILE, mode='w', newline='') as f:
        writer = csv.writer(f)
        writer.writerow(["LogTime", "Latitude", "Longitude", "Reported Date", "Destination", "DistanceToDest", "Bearing", "Direction", "RealHeading"])

def log_to_csv(lat, lon, date_str, destination_name, distance, bearing, direction, real_heading):
    with open(LOG_FILE, mode='a', newline='') as f:
        writer = csv.writer(f)
        log_time = datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S")
        writer.writerow([log_time, lat, lon, date_str, destination_name, distance, bearing, direction, real_heading])

def wait_for_gps_fix(serial_port):
    print("üîÑ Waiting for GPS fix...")
    while True:
        line = serial_port.readline().decode('ascii', errors='ignore').strip()
        if line:
            lat, lon, date_str = parse_custom_line(line)
            if lat is not None and lon is not None:
                print(f"üìç GPS Fix Acquired: ({lat:.6f}, {lon:.6f})")
                return lat, lon, date_str

def calculate_bearing(lat1, lon1, lat2, lon2):
    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])
    dlon = lon2 - lon1
    x = sin(dlon) * cos(lat2)
    y = cos(lat1) * sin(lat2) - sin(lat1) * cos(lat2) * cos(dlon)
    bearing = atan2(x, y)
    return (degrees(bearing) + 360) % 360

def bearing_to_cardinal(bearing):
    cardinals = ["N", "NE", "E", "SE", "S", "SW", "W", "NW", "N"]
    return cardinals[round(bearing / 45) % 8]

# ======= PATH MEMORY =======
path_memory = []

def navigate_to_destination(serial_port, dest_lat, dest_lon, dest_name):
    print(f"üó∫Ô∏è Navigating to {dest_name} at ({dest_lat:.6f}, {dest_lon:.6f})")
    while True:
        line = serial_port.readline().decode('ascii', errors='ignore').strip()
        if line:
            lat, lon, date_str = parse_custom_line(line)
            if lat is not None and lon is not None:
                distance = haversine(lat, lon, dest_lat, dest_lon)
                bearing = calculate_bearing(lat, lon, dest_lat, dest_lon)
                direction = bearing_to_cardinal(bearing)

                try:
                    real_heading = read_compass_heading()
                    print(f"üß≠ Real Compass Heading (simulated): {real_heading:.1f}¬∞")
                except Exception as e:
                    real_heading = "N/A"
                    print(f"‚ö†Ô∏è Compass error: {e}")

                path_memory.append((lat, lon))
                log_to_csv(lat, lon, date_str, dest_name, distance, bearing, direction, real_heading)

                print(f"üìç Current: ({lat:.6f}, {lon:.6f})")
                print(f"üéØ Target: {dest_name} | üìè Distance: {distance:.2f} m")
                print(f"üß≠ Direction: {direction} (bearing: {bearing:.1f}¬∞)")

                if distance < ARRIVAL_THRESHOLD_METERS:
                    print(f"üèÅ Arrived at {dest_name}!")
                    return True

                time.sleep(NAVIGATION_UPDATE_RATE)

def return_to_start(serial_port):
    print("\nüîÅ Returning to start through saved path...")
    for lat, lon in reversed(path_memory):
        print(f"\nüéØ Backtrack to ({lat:.6f}, {lon:.6f})")
        navigate_to_destination(serial_port, lat, lon, "Return Point")
        print("‚úÖ Reached checkpoint.")
        time.sleep(2)
    print("üè† Successfully returned to starting point.")

# ======= MAIN =======
def main():
    print("üöÄ Starting GPS Navigation System (Windows mode)...")

    try:
        print(f"üîå Connecting to GPS on {GPS_PORT}...")
        ser = serial.Serial(GPS_PORT, GPS_BAUD, timeout=1)
        print("‚úÖ GPS Connected.")
    except Exception as e:
        print(f"‚ùå GPS connection failed: {e}")
        return

    try:
        init_compass()
        init_csv()
        start_lat, start_lon, start_date = wait_for_gps_fix(ser)
        print(f"üö© Starting from: ({start_lat:.6f}, {start_lon:.6f})")

        for dest_lat, dest_lon, dest_name in DESTINATIONS:
            print(f"\nüéØ Navigating to: {dest_name}")
            navigate_to_destination(ser, dest_lat, dest_lon, dest_name)
            print(f"‚è≥ Pausing at {dest_name} for 5 seconds...")
            time.sleep(5)

        print("\n‚úÖ All destinations reached. Starting return...")
        return_to_start(ser)

    except KeyboardInterrupt:
        print("\nüõë Navigation stopped by user.")
    finally:
        ser.close()
        print(f"üìÅ Navigation log saved to: {LOG_FILE}")

if __name__ == "__main__":
    main()
